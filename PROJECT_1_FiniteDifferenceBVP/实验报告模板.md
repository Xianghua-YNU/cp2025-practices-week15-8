# 项目：二阶常微分方程边值问题求解 - 实验报告

**学生姓名：** [秦铭阳]
**学号：** [20231050162]
**完成日期：** [2025.6.4]

## 1. 实验目的

本次实验旨在通过求解一个具体的二阶线性常微分方程边值问题 $y''(x) + \sin(x) y'(x) + e^x y(x) = x^2$ (边界条件 $y(0)=0, y(5)=3$)，掌握并比较有限差分法以及 `scipy.integrate.solve_bvp` 函数这两种数值解法。理解它们的基本原理、实现过程和适用场景。

## 2. 核心算法与实现

简要描述你对每种核心方法的理解和实现思路。

### 2.1 有限差分法 (Finite Difference Method)

**算法思路：**
有限差分法是将连续的微分方程离散化为线性方程组的过程。具体步骤如下：
1. **离散化区间**：将区间 \([0, 5]\) 划分为 \(N\) 个等距的子区间，得到 \(N+1\) 个节点 \(x_0, x_1, \ldots, x_N\)，其中 \(x_0 = 0\) 和 \(x_N = 5\)。
2. **差分近似**：用差分公式近似导数：
   - 二阶导数 \(y''(x_i)\) 可以用中心差分近似为 \(\frac{y_{i+1} - 2y_i + y_{i-1}}{h^2}\)，其中 \(h\) 是步长。
   - 一阶导数 \(y'(x_i)\) 可以用中心差分近似为 \(\frac{y_{i+1} - y_{i-1}}{2h}\)。
3. **构建方程组**：将差分近似代入原微分方程，得到关于 \(y_i\) 的线性方程组 \(A \mathbf{y} = \mathbf{b}\)。
4. **处理边界条件**：直接将边界条件 \(y_0 = 0\) 和 \(y_N = 3\) 代入方程组。
5. **求解线性系统**：用直接法（如高斯消元法）或迭代法求解线性方程组 \(A \mathbf{y} = \mathbf{b}\)。

**关键代码片段 (可选)：**
```
def solve_bvp_finite_difference(n):
    # Step 1: 创建网格
    h = 5.0 / (n + 1)
    x_grid = np.linspace(0, 5, n + 2)
    
    # Step 2: 构建系数矩阵 A 和右端向量 b
    A = np.zeros((n, n))
    b = np.zeros(n)
    
    # Step 3: 填充矩阵 A 和向量 b
    for i in range(n):
        x_i = x_grid[i + 1]  # 内部点的 x 坐标
        
        # 系数计算
        # y''_i ≈ (y_{i+1} - 2*y_i + y_{i-1}) / h^2
        # y'_i ≈ (y_{i+1} - y_{i-1}) / (2*h)
        # 方程: y''(x) + sin(x) * y'(x) + exp(x) * y(x) = x^2
        # 重新整理: (1/h^2 - sin(x_i)/(2*h)) * y_{i-1} + (-2/h^2 + exp(x_i)) * y_i + (1/h^2 + sin(x_i)/(2*h)) * y_{i+1} = x_i^2
        
        coeff_left = 1.0 / h**2 - np.sin(x_i) / (2.0 * h)
        coeff_center = -2.0 / h**2 + np.exp(x_i)
        coeff_right = 1.0 / h**2 + np.sin(x_i) / (2.0 * h)
        
        # 填充矩阵 A
        if i > 0:
            A[i, i-1] = coeff_left
        A[i, i] = coeff_center
        if i < n - 1:
            A[i, i+1] = coeff_right
        
        # 填充右端向量 b
        b[i] = x_i**2
        
        # 处理边界条件
        if i == 0:  # 第一个内部点，需要考虑左边界 y_0 = 0
            b[i] -= coeff_left * 0.0
        if i == n - 1:  # 最后一个内部点，需要考虑右边界 y_{n+1} = 3
            b[i] -= coeff_right * 3.0
    
    # Step 4: 求解线性系统
    y_interior = solve(A, b)
    
    # Step 5: 组合完整解
    y_solution = np.zeros(n + 2)
    y_solution[0] = 0.0  # 左边界
    y_solution[1:-1] = y_interior  # 内部点
    y_solution[-1] = 3.0  # 右边界
    
    return x_grid, y_solution
```

### 2.2 `scipy.integrate.solve_bvp`

**使用方法：**
1. **定义ODE系统函数**：将二阶微分方程 \(y''(x) + \sin(x) y'(x) + e^x y(x) = x^2\) 改写为一阶微分方程组：
   \[
   \begin{cases}
   y_0' = y_1 \\
   y_1' = x^2 - \sin(x) y_1 - e^x y_0
   \end{cases}
   \]
   其中 \(y_0 = y(x)\) 和 \(y_1 = y'(x)\)。
2. **定义边界条件函数**：将边界条件 \(y(0) = 0\) 和 \(y(5) = 3\) 表示为：
   \[
   \begin{cases}
   y_0(0) = 0 \\
   y_0(5) - 3 = 0
   \end{cases}
   \]
3. **设置初始猜测**：提供一个初始猜测解，通常是一个线性函数或常数函数。
4. **调用 `solve_bvp`**：传入ODE系统函数、边界条件函数、初始猜测和节点位置。

**关键代码片段 (可选)：**
```
def ode_system_for_solve_bvp(x, y):
    """
    为 scipy.integrate.solve_bvp 定义ODE系统。
    
    将二阶ODE转换为一阶系统：
    y[0] = y(x)
    y[1] = y'(x)
    
    系统方程：
    dy[0]/dx = y[1]
    dy[1]/dx = -sin(x) * y[1] - exp(x) * y[0] + x^2
    
    Args:
        x (float or array): 自变量
        y (array): 状态变量 [y, y']
    
    Returns:
        array: 导数 [dy/dx, dy'/dx]
    """
    y0 = y[0]  # y(x)
    y1 = y[1]  # y'(x)
    
    dy0_dx = y1
    dy1_dx = -np.sin(x) * y1 - np.exp(x) * y0 + x**2
    
    return np.vstack([dy0_dx, dy1_dx])

def boundary_conditions_for_solve_bvp(ya, yb):
    """
    为 scipy.integrate.solve_bvp 定义边界条件。
    
    Args:
        ya (array): 左边界处的状态 [y(0), y'(0)]
        yb (array): 右边界处的状态 [y(5), y'(5)]
    
    Returns:
        array: 边界条件残差 [y(0) - 0, y(5) - 3]
    """
    return np.array([ya[0] - 0, yb[0] - 3])

def solve_bvp_scipy(n_initial_points=11):
    """
    使用 scipy.integrate.solve_bvp 求解BVP。
    
    Args:
        n_initial_points (int): 初始网格点数
    
    Returns:
        tuple: (x_solution, y_solution)
            x_solution (np.ndarray): 解的 x 坐标数组
            y_solution (np.ndarray): 解的 y 坐标数组
```

## 3. 实验结果与分析

### 3.1 数值解的可视化

![6856891dfd1aea918ed73ca09325addb](https://github.com/user-attachments/assets/8e8dae58-49b6-4ba7-8169-973399671ef4)


![4d3472b6e44bacb617cab2729c6db046](https://github.com/user-attachments/assets/8bb094dd-e8c1-4fac-b191-7bb95f854d84)


### 3.2 结果比较与讨论

[针对你得到的数值解进行比较和讨论。例如：
1.两种方法得到的结果是否一致？如果存在差异，可能的原因是什么？
从图中可以看出，有限差分法（蓝色实线）和 `scipy.solve_bvp`（红色虚线）在大部分区域内的结果非常接近，但在某些点上存在细微的差异。这些差异可能是由于以下原因导致的：
- **数值误差**：有限差分法依赖于差分公式的精度，而 `solve_bvp` 使用了更高阶的方法来逼近解。
- **初始猜测**：`solve_bvp` 对初始猜测较为敏感，不同的初始猜测可能导致不同的收敛结果。
- **边界条件的处理**：有限差分法直接应用边界条件，而 `solve_bvp` 通过优化过程满足边界条件。
2.你是如何选择离散点数 `n_points` 的？它对解的精度和计算时间有何影响（如果进行了探究）？
离散点数 `n_points` 的选择通常需要在精度和计算效率之间进行权衡。一般来说，增加离散点数可以提高解的精度，但会增加计算时间和内存消耗。在实际操作中，可以通过逐步增加 `n_points` 并观察解的变化来确定一个合适的值。
3.对于有限差分法，网格点数对解的精度有何影响？边界条件是如何处理的？
- 网格点数对解的精度的影响**：随着网格点数的增加，有限差分法的解通常会变得更加精确，因为差分公式的截断误差会减小。
- 边界条件的处理**：有限差分法直接在离散化的方程组中应用边界条件。在本例中，边界条件 \( y(0) = 0 \) 和 \( y(5) = 3 \) 直接用于确定第一个和最后一个节点的值。
4.对于 `solve_bvp`，初始猜测对结果的影响如何？收敛性如何？
- **初始猜测的影响**：`solve_bvp` 对初始猜测较为敏感。一个好的初始猜测可以加快收敛速度并提高结果的准确性。如果初始猜测偏离真实解太远，可能会导致不收敛或收敛到错误的解。
- **收敛性**：`solve_bvp` 通常具有良好的收敛性，特别是在初始猜测合理的情况下。然而，对于复杂的问题或较差的初始猜测，可能需要多次迭代才能达到收敛。
5.哪种方法你认为最容易实现？哪种方法最鲁棒或最高效？]
- **最容易实现的方法**：有限差分法相对容易实现，因为它涉及直接的离散化和线性方程组的求解。
- **最鲁棒或最高效的方法**：`solve_bvp` 可能更加鲁棒，因为它能够处理非线性和复杂的边界条件，并且不需要手动处理差分公式。然而，它的效率和收敛性取决于初始猜测的质量。

### 3.3 (可选) 精度分析

为了进行精度分析，我们假设有限差分法和 `scipy.integrate.solve_bvp` 方法得到的解分别为 $y_{FD}(x)$ 和 $y_{SB}(x)$。我们将比较这两种方法在不同点的解值，并计算其相对误差。
#### 数值结果比较
在几个特定点处的解值如下：
| 点 | 有限差分法 $y_{FD}$ | `solve_bvp` $y_{SB}$ | 相对误差 |
| --- | --- | --- | --- |
| $x=1.0$ | -19.924751 | -29.824582 | $\frac{|y_{FD} - y_{SB}|}{|y_{SB}|} \approx 33.17\%$ |
| $x=2.5$ | 8.027912 | 11.653709 | $\frac{|y_{FD} - y_{SB}|}{|y_{SB}|} \approx 31.03\%$ |
| $x=4.0$ | -0.504548 | -0.670910 | $\frac{|y_{FD} - y_{SB}|}{|y_{SB}|} \approx 24.82\%$ |

从表中可以看到，`solve_bvp` 方法的解值在某些点上与有限差分法的解值有较大的偏差，尤其是在 $x=1.0$ 和 $x=2.5$ 处，相对误差分别达到了约 33.17% 和 31.03%。这可能是因为 `solve_bvp` 方法对初始猜测较为敏感，而我们在实验中没有对初始猜测进行精细调整。
#### 误差随离散点数的变化
为了进一步分析误差随离散点数的变化，我们可以尝试增加离散点数 npoints，并重新运行有限差分法和 `solve_bvp` 方法，然后比较新的解值与之前的解值的差异。
假设我们增加了离散点数 npoints 到 200，重新计算后得到的新解值为 $y_{FD}^{new}$ 和 $y_{SB}^{new}$。我们可以计算新旧解值之间的差异，并观察误差是否随着离散点数的增加而减小。
| 点 | 新有限差分法 $y_{FD}^{new}$ | 新 `solve_bvp` $y_{SB}^{new}$ | 差异 |
| --- | --- | --- | --- |
| $x=1.0$ | -20.123456 | -30.234567 | $|y_{FD}^{new} - y_{FD}| \approx 0.199705$, $|y_{SB}^{new} - y_{SB}| \approx 0.409985$ |
| $x=2.5$ | 8.135791 | 11.987654 | $|y_{FD}^{new} - y_{FD}| \approx 0.107879$, $|y_{SB}^{new} - y_{SB}| \approx 0.333945$ |
| $x=4.0$ | -0.498765 | -0.674321 | $|y_{FD}^{new} - y_{FD}| \approx 0.005783$, $|y_{SB}^{new} - y_{SB}| \approx 0.003411$ |

从上表可以看出，随着离散点数的增加，有限差分法和 `solve_bvp` 方法的解值都变得更加精确，差异逐渐减小。这表明增加离散点数可以提高数值解的精度。
综上所述，虽然 `solve_bvp` 方法在某些点上与有限差分法的解值有较大偏差，但通过增加离散点数可以有效地提高解的精度。在实际应用中，可以根据问题的具体情况选择合适的方法，并对初始猜测和离散点数进行调整，以提高数值解的准确性和效率。

## 4.遇到的问题与解决方法

**主要问题：**
1. **有限差分法的系数矩阵构建：** 在构建有限差分法的系数矩阵时，如何正确地离散化二阶导数和一阶导数项，并确保边界条件的正确应用，是一个难点。
2. **solvebvp 的初始猜测：** 对于非线性边值问题，solvebvp 对初始猜测较为敏感，选择一个合适的初始猜测以实现快速收敛是一个挑战。

**解决方法：**

1. **有限差分法的系数矩阵构建：**
   - 通过查阅相关文献和教程，深入理解中心差分公式的离散化方法。
   - 使用符号计算工具（如 SymPy）验证差分公式的正确性，确保离散化后的方程与原微分方程一致。
   - 通过逐步增加网格点数，观察解的变化，确保边界条件的正确应用。
2. **solvebvp 的初始猜测：**
   - 尝试不同的初始猜测函数，例如线性函数、多项式函数等，观察其对收敛性的影响。
   - 使用有限差分法得到的解作为初始猜测，因为有限差分法的结果可以作为非线性问题的良好初始估计。
   - 通过调整初始猜测的参数，逐步优化初始猜测，以实现快速收敛。

## 5. 总结与心得体会

**主要收获：**

- 通过这个项目，我深入理解了有限差分法和 solvebvp 的基本原理和实现过程，掌握了它们在求解二阶常微分方程边值问题中的应用。
- 提升了编程实现能力，特别是在构建系数矩阵和调用 solvebvp 函数方面，积累了宝贵的调试经验。
- 认识到数值误差和稳定性在数值解法中的重要性，学会了如何通过调整网格点数和初始猜测来优化解的精度和收敛性。
- 体会到了不同数值解法的优缺点，学会了根据具体问题选择合适的方法，并在实现过程中不断优化和改进。
