# 项目：二阶常微分方程边值问题求解 - 实验报告

**学生姓名：** [秦铭阳]
**学号：** [20231050162]
**完成日期：** [2025.6.4]

## 1. 实验目的

本次实验旨在通过求解一个具体的二阶线性常微分方程边值问题 $y''(x) + \sin(x) y'(x) + e^x y(x) = x^2$ (边界条件 $y(0)=0, y(5)=3$)，掌握并比较有限差分法以及 `scipy.integrate.solve_bvp` 函数这两种数值解法。理解它们的基本原理、实现过程和适用场景。

## 2. 核心算法与实现

简要描述你对每种核心方法的理解和实现思路。

### 2.1 有限差分法 (Finite Difference Method)

**算法思路：**
有限差分法是将连续的微分方程离散化为线性方程组的过程。具体步骤如下：
1. **离散化区间**：将区间 \([0, 5]\) 划分为 \(N\) 个等距的子区间，得到 \(N+1\) 个节点 \(x_0, x_1, \ldots, x_N\)，其中 \(x_0 = 0\) 和 \(x_N = 5\)。
2. **差分近似**：用差分公式近似导数：
   - 二阶导数 \(y''(x_i)\) 可以用中心差分近似为 \(\frac{y_{i+1} - 2y_i + y_{i-1}}{h^2}\)，其中 \(h\) 是步长。
   - 一阶导数 \(y'(x_i)\) 可以用中心差分近似为 \(\frac{y_{i+1} - y_{i-1}}{2h}\)。
3. **构建方程组**：将差分近似代入原微分方程，得到关于 \(y_i\) 的线性方程组 \(A \mathbf{y} = \mathbf{b}\)。
4. **处理边界条件**：直接将边界条件 \(y_0 = 0\) 和 \(y_N = 3\) 代入方程组。
5. **求解线性系统**：用直接法（如高斯消元法）或迭代法求解线性方程组 \(A \mathbf{y} = \mathbf{b}\)。

**关键代码片段 (可选)：**
```
def solve_bvp_finite_difference(n):
    # Step 1: 创建网格
    h = 5.0 / (n + 1)
    x_grid = np.linspace(0, 5, n + 2)
    
    # Step 2: 构建系数矩阵 A 和右端向量 b
    A = np.zeros((n, n))
    b = np.zeros(n)
    
    # Step 3: 填充矩阵 A 和向量 b
    for i in range(n):
        x_i = x_grid[i + 1]  # 内部点的 x 坐标
        
        # 系数计算
        # y''_i ≈ (y_{i+1} - 2*y_i + y_{i-1}) / h^2
        # y'_i ≈ (y_{i+1} - y_{i-1}) / (2*h)
        # 方程: y''(x) + sin(x) * y'(x) + exp(x) * y(x) = x^2
        # 重新整理: (1/h^2 - sin(x_i)/(2*h)) * y_{i-1} + (-2/h^2 + exp(x_i)) * y_i + (1/h^2 + sin(x_i)/(2*h)) * y_{i+1} = x_i^2
        
        coeff_left = 1.0 / h**2 - np.sin(x_i) / (2.0 * h)
        coeff_center = -2.0 / h**2 + np.exp(x_i)
        coeff_right = 1.0 / h**2 + np.sin(x_i) / (2.0 * h)
        
        # 填充矩阵 A
        if i > 0:
            A[i, i-1] = coeff_left
        A[i, i] = coeff_center
        if i < n - 1:
            A[i, i+1] = coeff_right
        
        # 填充右端向量 b
        b[i] = x_i**2
        
        # 处理边界条件
        if i == 0:  # 第一个内部点，需要考虑左边界 y_0 = 0
            b[i] -= coeff_left * 0.0
        if i == n - 1:  # 最后一个内部点，需要考虑右边界 y_{n+1} = 3
            b[i] -= coeff_right * 3.0
    
    # Step 4: 求解线性系统
    y_interior = solve(A, b)
    
    # Step 5: 组合完整解
    y_solution = np.zeros(n + 2)
    y_solution[0] = 0.0  # 左边界
    y_solution[1:-1] = y_interior  # 内部点
    y_solution[-1] = 3.0  # 右边界
    
    return x_grid, y_solution
```

### 2.2 `scipy.integrate.solve_bvp`

**使用方法：**
1. **定义ODE系统函数**：将二阶微分方程 \(y''(x) + \sin(x) y'(x) + e^x y(x) = x^2\) 改写为一阶微分方程组：
   \[
   \begin{cases}
   y_0' = y_1 \\
   y_1' = x^2 - \sin(x) y_1 - e^x y_0
   \end{cases}
   \]
   其中 \(y_0 = y(x)\) 和 \(y_1 = y'(x)\)。
2. **定义边界条件函数**：将边界条件 \(y(0) = 0\) 和 \(y(5) = 3\) 表示为：
   \[
   \begin{cases}
   y_0(0) = 0 \\
   y_0(5) - 3 = 0
   \end{cases}
   \]
3. **设置初始猜测**：提供一个初始猜测解，通常是一个线性函数或常数函数。
4. **调用 `solve_bvp`**：传入ODE系统函数、边界条件函数、初始猜测和节点位置。

**关键代码片段 (可选)：**
```
def ode_system_for_solve_bvp(x, y):
    """
    为 scipy.integrate.solve_bvp 定义ODE系统。
    
    将二阶ODE转换为一阶系统：
    y[0] = y(x)
    y[1] = y'(x)
    
    系统方程：
    dy[0]/dx = y[1]
    dy[1]/dx = -sin(x) * y[1] - exp(x) * y[0] + x^2
    
    Args:
        x (float or array): 自变量
        y (array): 状态变量 [y, y']
    
    Returns:
        array: 导数 [dy/dx, dy'/dx]
    """
    y0 = y[0]  # y(x)
    y1 = y[1]  # y'(x)
    
    dy0_dx = y1
    dy1_dx = -np.sin(x) * y1 - np.exp(x) * y0 + x**2
    
    return np.vstack([dy0_dx, dy1_dx])

def boundary_conditions_for_solve_bvp(ya, yb):
    """
    为 scipy.integrate.solve_bvp 定义边界条件。
    
    Args:
        ya (array): 左边界处的状态 [y(0), y'(0)]
        yb (array): 右边界处的状态 [y(5), y'(5)]
    
    Returns:
        array: 边界条件残差 [y(0) - 0, y(5) - 3]
    """
    return np.array([ya[0] - 0, yb[0] - 3])

def solve_bvp_scipy(n_initial_points=11):
    """
    使用 scipy.integrate.solve_bvp 求解BVP。
    
    Args:
        n_initial_points (int): 初始网格点数
    
    Returns:
        tuple: (x_solution, y_solution)
            x_solution (np.ndarray): 解的 x 坐标数组
            y_solution (np.ndarray): 解的 y 坐标数组
```

## 3. 实验结果与分析

### 3.1 数值解的可视化

![6856891dfd1aea918ed73ca09325addb](https://github.com/user-attachments/assets/8e8dae58-49b6-4ba7-8169-973399671ef4)

### 3.2 结果比较与讨论

[针对你得到的数值解进行比较和讨论。例如：
- 两种方法得到的结果是否一致？如果存在差异，可能的原因是什么？
- 从图中可以看出，有限差分法（蓝色实线）和 `scipy.solve_bvp`（红色虚线）在大部分区域内的结果非常接近，但在某些点上存在细微的差异。这些差异可能是由于以下原因导致的：
- **数值误差**：有限差分法依赖于差分公式的精度，而 `solve_bvp` 使用了更高阶的方法来逼近解。
- **初始猜测**：`solve_bvp` 对初始猜测较为敏感，不同的初始猜测可能导致不同的收敛结果。
- 
- **边界条件的处理**：有限差分法直接应用边界条件，而 `solve_bvp` 通过优化过程满足边界条件。
- 你是如何选择离散点数 `n_points` 的？它对解的精度和计算时间有何影响（如果进行了探究）？
- 对于有限差分法，网格点数对解的精度有何影响？边界条件是如何处理的？
- 对于 `solve_bvp`，初始猜测对结果的影响如何？收敛性如何？
- 哪种方法你认为最容易实现？哪种方法最鲁棒或最高效？]

### 3.3 (可选) 精度分析

[如果你找到了问题的解析解或高精度参考解，并进行了误差分析，请在此处展示你的结果和讨论。例如，比较不同方法的误差大小，分析误差随离散点数的变化等。]

## 4.遇到的问题与解决方法

**主要问题：**
[列出你在项目过程中遇到的1-2个主要技术问题或理解上的难点。]

**解决方法：**
[描述你是如何思考并解决这些问题的。]

## 5. 总结与心得体会

**主要收获：**
[总结通过这个项目你学到了哪些关于BVP数值解法的重要知识和技能。例如：对不同方法原理的深入理解、编程实现能力的提升、调试技巧、对数值误差和稳定性的认识等。3-5句话即可。]

